
@pg.production('expr : IDENTIFIER')
and
@pg.production('expr : LPAREN expr RPAREN')
	- problem?
	- (x) would be parsed as an expr right now

	- so arg_list has to have precedence


func_def : IDENTIFIER LPAREN RPAREN { ... }
func_def : IDENTIFIER LPAREN arg_list RPAREN { ... }

arg_list : IDENTIFIER
 		 | IDENTIFIER , arg_list


- function definition vs calling
- f() case

func_call : INDENTIFIER LPAREN RPAREN
func_call : INDENTIFIER LPAREN arg_list RPAREN

arg_list : expr
	     | expr , arg_list

x()
x ()

function name(){

}

function name(){ block }
function name(){ block return }
function name(x,y,z){ block return }


func_def : FUNCTION IDENTIFIER LPAREN RPAREN LBRACE block RBRACE
	     | FUNCTION IDENTIFIER LPAREN RPAREN LBRACE block return RBRACE
	     | FUNCTION IDENTIFIER LPAREN arg_list RPAREN LBRACE block return RBRACE


return : RETURN
	   | RETURN LPAREN arg_list RPAREN


when defining a function we pass an arg_list of variables
	- shouldn't be evaluated, they don't have value in this context
	- and def f(x, 1) has no purpose

	- what about shadowing?
		- x = 10
		  def test(x) ...

	- arg lists for definitions and calls are kind of mutually exclusive cases
	- how do we know not to evaluate them, even if the variable has a value locally?
		- do we pass the caller object to arg_list?
			- if it's a function we eval
			- else we just return a list of names


evaluating a function object --> ... ?
	- passed
		- possibly empty list of strings for variable names
		- block of statement(s)
		- optional return object

	- if no return object than evaluating the function just evals the block
	  and returns nothing
	  	- maybe returns 1/True if no errors else 0/False

	- we need a local variable space and we're evaluating the block wrt that
		- how?
		- pass a namespace object to block eval
			- default is global
		- we could have local names that reference global objects

	- don't aim for the perfect solution initially, funner that way and you'll learn more

-----------------------

- passing an object to a class passes a reference
	- updates in object are inherited
	- same id

- passing namespace at init..
	- inefficient? unnecessary?
	- if changes in the space are updated then we only have to add in init and not every eval?

	- actually we can't assign a block a namespace on creation because we don't know if it will end up in a function yet...
		- same with all statements I think

- is there any reason to actually set the namespace
  as an attribute?
  	- if we want to know what space it belongs to/evals with
  	- code as an object, knowing what the parent/caller is


- functions create their own namespace that should be destroyed after
  	- is this an object of @main?


- add space to eval of everything...
	- it only has impact for literals and function calls (??)
	- and variables


------

- Return object and evaluating function block
	- function f(a,b){ 
		  a = a * 10
		  let c = a - b
	      return(a + b + c)
	}
	- f(0, 10) -> -20

	- block can be empty if we are just returning the value of a statement
		- so block, args, and return are optional, but we need at least a block OR a return..
		- func without block isn't included in current parser definition

	- wait.. we're writing eval for FunctionDef, that doesn't make sense

	- evaluating function call
		- create new namespace with unique name referencing function (and parent/caller?)
			- probably want to know where it is being called
		- eval arguments and give variables declared in FunctionDef those values
			- (in the function namespace)
			- how?
				- FunctionDef should be an object of the current namespace
				- get its args attribute (list of variables names)
		- pass this to block.eval
		- eval each of the statements in block updating namespace if needed
			- might involve calling functions
		- pass the final namespace to return object
		- evaluate last statement with that namespace and pass result back to FunctionDef
		- ...

	- is a return object needed?
		- the token has to be parsed but is it actually doing anything special?
		- it's just the final eval statement of the block

		- it's a special statement though because you can't assign things or define
		  identifiers or functions
		  	- it's a limited expression we don't have a class for


- parent_space of FunctionDef and FunctionCall can be different
	- *often will be
	- funcdef needs to be added to the namespace it's declared in
		- do we know what this is on init? what if we have a function in a function?
		- if we parse a function and don't yet know it's inside another larger function then
		  the space would be incorrectly set as @main
		  	- so add the space on eval?

- function f(a,b){ 
      a = a * 10
	  let c = a - b
	  return(a + b + c)
	  }

	  - no case yet for variable assignment without let..
	  - a = a * 10 is a good case to test
	  	- still have to add +=, -=, etc eventually
	  - assuming 'a' is already defined, what is this class?
	  	- it's just a new case of Assignment
	  		- so we need namespace in Assignment init
	  			- but what if it's inside a function like here? aaaah
	  				- calling eval in Assignment init was a mistake earlier (?)
	  				- interesting that worked