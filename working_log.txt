
[x]exponents
- multiple lines
- different variable declarations
- functions
- different data types

- program structure, parsing, etc

# DIGIT? or no point going to deeper level?
# CHAR?

TODO: Implicit multiplication kind of works but '(1) (2)' would be incorrectly parsed as multiplying...
TODO: Handle assigning boolean expressions to variables

IDEA: ('case1', '1+1', eval(self[-1])) ) => ('case1', '1+1', 2)
--> assigning element while declaring in relation to other elements
-----------------

( 03:54:30 PM | Tue Oct 29 2019 )
- take a break then try adding lines and other data types

( 05:43:45 PM | Tue Oct 29 2019 )
- added exponents which needed new rules/patterns and order of operations update
- added more negative cases like -(-2), 1*-1 and ---(3)

( 04:25:30 PM | Wed Oct 30 2019 )
- spent last half hour getting pycharm installed and looking ok
- now fixing all suggestions
- was close to getting variables working but then things started to break again
- experimented with NO_EQUALS in parsing variable assignments for a while

( 07:20:46 PM | Wed Oct 30 2019 )
- all tests in main work, committed to new branch
- variable assignments to complex expressions seem to work
    - e.g. let num = 292.1*(0.24^(-1))
- still have 5 shift/reduce warnings
- starting work on multiple lines

( 10:15:40 PM | Wed Oct 30 2019 )
- got pretty heavy into debugging, learned a lot about tracing things through the stack
- pycharm or a good IDE is absolutely necessary...
- writing unit tests for the past while, wasting a bit of time trying to be too fancy

( 11:25:34 PM | Wed Oct 30 2019 )
- found a better and simpler unit test method after trying a few
    - easy to parametrize and print all cases and results
- most tests written for where interpreter is at
- still some weird broken cases and things left hanging like ((2)(2)(2))
- can't unittest variables at this point

( 04:41:29 AM | Thu Oct 31 2019 )
- starting work again, target is multiline

( 06:51:10 AM | Thu Oct 31 2019 )
- figured out a way to unittest variables at this stage
    - pretty surprised that "let x = 19+(2*42/(-0.125))" worked
    - but the name storage model atm is disturbing
- spent the last hour+ reading about terminal vs nonterminal symbols, context-free grammars,
  polish notation (and reverse), statements vs expressions and python's EBNF ...

( 09:08:05 AM | Thu Oct 31 2019 )
- skipped 1930, emailed neda
- after searching google on and off for hours and looking at different parsers altogether to
  figure out how to handle new lines I finally found an amazing github repo, now using this
        - program : statement
          statement : stmt NEWLINE
          statement : stmt $end

        - NEWLINE and $end aren't tokens, NEWLINE is regex, $end is special value I noticed earlier
        - removing the 3rd production rule with $end causes every single unit test to fail
        - ......

- still can't parse multiple lines but this feels like the missing piece

( 03:18:11 AM | Sat Nov 02 2019 )
- starting work again, nothing much happened since last entry

( 05:26:06 AM | Sat Nov 02 2019 )
- got 2 line statements working in the past hour(!)
- starting to understand the parser a lot more
    - it uses production rules to try to replace the most tokens with a single nonterminal
      and then evaluates that
- the trick was @pg.production('statement : stmt NEWLINE stmt') and then handling that as
  a CompoundStatement where we evaluate each line on it's own
    - before we would parse all the way to e.g. Add NEWLINE SUB and then just throw out
      the SUB because ADD NEWLINE taken together is a stmt
    - obviously you can't eval every line on its own but this is a start
- 2 line variable assign/eval works as well but there's another jump to getting 3+ lines
- unittests for multiple lines is a lot of inefficient gymnastics atm

( 07:12:10 AM | Sat Nov 02 2019 )
- basically have 3+ line blocks working
- looked at Braid github a bit, felt a little like cheating but I want to get past this area soon
  and all the code is still my own take
- some problems now parsing variables on different lines, gonna call it a night
- CompoundStatement isn't needed anymore now that we have blocks
    - appending statement lines to a Block object and then evaluating them all in a loop

( 06:56:23 PM | Sat Nov 02 2019 )
- working for past 2.5 hours maybe
- problems from this morning with multiline variables were all regex related
    - let was only matching at start of string
- function calls with multiple arguments working
    e.g.   let x = 10
           print((x+1)*18, x)
- of course we don't have function definitions or any actual functions to call..

( 08:04:15 AM | Mon Nov 04 2019 )
- working since midnight at least
- function definitions and calls are parsing and evaluating
    - added NameSpace object to every eval and production
    - functions define their own namespace, arguments are evaluated and passed in
    - haven't tried every type of funcdef
- code has gotten pretty crazy
    - parser33 and ast are both around 300 lines
- "function test(a) { a = a * 10 \n return(a + 2) } \n test(2)" -> [None, 22]
- figuring out difference between FunctionDef/FunctionCall and their interaction was challenging
    - "wait, no that actually doesn't make any sense"
    - still lots of different bugs and things to figure out
- wrote "Compile" class (in heavy quotes lol) that makes printing and examining output easier

( 09:21:46 AM | Mon Nov 04 2019 )
- rewrote unittests for compile object
- more function definitions working
- starting to make silly mistakes and have to go to class soon..
- ast needs pretty big rewrite once fleshed out more

( 05:37:16 AM | Tue Nov 05 2019 )
- working for last 4 hours or so
- lost of housecleaning in ast and parser
- added boolean operands and equivalance/comparison (!=, ==, <, >, etc), in the process
  of testing them
- still only have numbers for datatypes
- got one or two more function defs working
- spent the last 30-45 min or more fixing negative operator
    - made it way simpler by adding another case to the regex so a Minus token wouldn't be
      parsed instead in cases like -9 * -10
    - got rid of   number  : NEGATIVE FLOAT   and   expr  : NEGATIVE LPAREN expr RPAREN
                           | NEGATIVE INTEGER             | NEGATIVE NEGATIVE expr
    - hadn't really looked at that area since adding statements
    - tried stmt : NEGATIVE expr  ->  Mul(expr, Integer(-1))
          - seemed pretty clever at the time but didn't work and inefficient
          - still wondering if compound negative statements will need to be added differently
    - instead just using the FlipSign object I almost threw out earlier while cleaning
    - it was able to replace all 4 of those rules and now stuff like "-9 * -10" works
    - also tried   expr | NEGATIVE NEGATIVE expr  which alone caused 18 reduce/reduce conflicts
                   expr | NEGATIVE expr

- ehh.. spoke too soon, half around later and running into some negative problems evaluating variables, FlipSign has some downstream effects

( 07:27:44 AM | Tue Nov 05 2019 )
- really annoying case ->  "let x = 1 \n -x * 2"
  - seems simple but but i've been stuck here for a while
  - finally fixed it by expanding the negative regex expression even more, which is starting to seem ridiculous
      - "^-|(?<=\()-|(?<=[\+\-\*\/\^])-|(?<==\s)-|(?<=[^0-9./)])-(?=[0-9.a-zA-Z])"
      - actually just made it slightly longer and fixed a case after pasting it in here
      - isn't this what the parser is for? can't we write in all the cases where a negative symbol should be added instead of minus?..
      - still doesn't fully work.. "let x = 1 \n --x * 2" ..


( 07:10:26 AM | Thu Nov 07 2019 )
- working for last 7+ hours
- nested function calls work, e.g "f(g(x))"
- expressions containing function calls work, e.g. "1 + f()"
    - e.g. "function f(a,b){ let c = (a+1)/(b - 1) \n return(c) } ; 
            function g(x){return(x+1)} ; f(g(1),7) + 2"
    - this took a lot of work, having "stmt -> func_call" was the biggest problem
      and I didn't think of just removing of it
    - now "expr : func_call" as we wanted for a while
    - don't know why I didn't see that.. definitions can contain new lines but calls don't
      so there's no good reason it can't be an expr, just assumed that rule was needed
- realized in fixing sr/rr conflicts that arg_list object shouldn't be the same 
  for func call/def, oops..
    - it worked but required uncessary handling, func_def should only be passed identifiers
- cleaned up function section of ast
- fixed precedence rules, a bunch were unecessarry or wrong
    - order of operators for POW and NOT.. 
- added ** to regex for pow, new arithmetic unittests using add/sub/mul/div
  that didn't work initally
- simplified some production rules
    - a : b  (both nonterminal) is only really useful/meaningful if it's 
    restricting the use of b or creating an object
- negative still causing issues, new rule I added in last entry makes it match 1 -1 or x-1