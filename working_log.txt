
[x]exponents
- multiple lines
- different variable declarations
- functions
- different data types

- program structure, parsing, etc

# DIGIT? or no point going to deeper level?
# CHAR?

TODO: Implicit multiplication kind of works but '(1) (2)' would be incorrectly parsed as multiplying...
TODO: Handle assigning boolean expressions to variables

IDEA: ('case1', '1+1', eval(self[-1])) ) => ('case1', '1+1', 2)
--> assigning element while declaring in relation to other elements
-----------------

( 03:54:30 PM | Tue Oct 29 2019 )
- take a break then try adding lines and other data types

( 05:43:45 PM | Tue Oct 29 2019 )
- added exponents which needed new rules/patterns and order of operations update
- added more negative cases like -(-2), 1*-1 and ---(3)

( 04:25:30 PM | Wed Oct 30 2019 )
- spent last half hour getting pycharm installed and looking ok
- now fixing all suggestions
- was close to getting variables working but then things started to break again
- experimented with NO_EQUALS in parsing variable assignments for a while

( 07:20:46 PM | Wed Oct 30 2019 )
- all tests in main work, committed to new branch
- variable assignments to complex expressions seem to work
    - e.g. let num = 292.1*(0.24^(-1))
- still have 5 shift/reduce warnings
- starting work on multiple lines

( 10:15:40 PM | Wed Oct 30 2019 )
- got pretty heavy into debugging, learned a lot about tracing things through the stack
- pycharm or a good IDE is absolutely necessary...
- writing unit tests for the past while, wasting a bit of time trying to be too fancy

( 11:25:34 PM | Wed Oct 30 2019 )
- found a better and simpler unit test method after trying a few
    - easy to parametrize and print all cases and results
- most tests written for where interpreter is at
- still some weird broken cases and things left hanging like ((2)(2)(2))
- can't unittest variables at this point

( 04:41:29 AM | Thu Oct 31 2019 )
- starting work again, target is multiline

( 06:51:10 AM | Thu Oct 31 2019 )
- figured out a way to unittest variables at this stage
    - pretty surprised that "let x = 19+(2*42/(-0.125))" worked
    - but the name storage model atm is disturbing
- spent the last hour+ reading about terminal vs nonterminal symbols, context-free grammars,
  polish notation (and reverse), statements vs expressions and python's EBNF ...

( 09:08:05 AM | Thu Oct 31 2019 )
- skipped 1930, emailed neda
- after searching google on and off for hours and looking at different parsers altogether to
  figure out how to handle new lines I finally found an amazing github repo, now using this
        - program : statement
          statement : stmt NEWLINE
          statement : stmt $end

        - NEWLINE and $end aren't tokens, NEWLINE is regex, $end is special value I noticed earlier
        - removing the 3rd production rule with $end causes every single unit test to fail
        - ......

- still can't parse multiple lines but this feels like the missing piece

( 03:18:11 AM | Sat Nov 02 2019 )
- starting work again, nothing much happened since last entry

( 05:26:06 AM | Sat Nov 02 2019 )
- got 2 line statements working in the past hour(!)
- starting to understand the parser a lot more
    - it uses production rules to try to replace the most tokens with a single nonterminal
      and then evaluates that
- the trick was @pg.production('statement : stmt NEWLINE stmt') and then handling that as
  a CompoundStatement where we evaluate each line on it's own
    - before we would parse all the way to e.g. Add NEWLINE SUB and then just throw out
      the SUB because ADD NEWLINE taken together is a stmt
    - obviously you can't eval every line on its own but this is a start
- 2 line variable assign/eval works as well but there's another jump to getting 3+ lines
- unittests for multiple lines is a lot of inefficient gymnastics atm

( 07:12:10 AM | Sat Nov 02 2019 )
- basically have 3+ line blocks working
- looked at Braid github a bit, felt a little like cheating but I want to get past this area soon
  and all the code is still my own take
- some problems now parsing variables on different lines, gonna call it a night
- CompoundStatement isn't needed anymore now that we have blocks
    - appending statement lines to a Block object and then evaluating them all in a loop

( 06:56:23 PM | Sat Nov 02 2019 )
- working for past 2.5 hours maybe
- problems from this morning with multiline variables were all regex related
    - let was only matching at start of string
- function calls with multiple arguments working
    e.g.   let x = 10
           print((x+1)*18, x)
- of course we don't have function definitions or any actual functions to call..

( 08:04:15 AM | Mon Nov 04 2019 )
- working since midnight at least
- function definitions and calls are parsing and evaluating
    - added NameSpace object to every eval and production
    - functions define their own namespace, arguments are evaluated and passed in
    - haven't tried every type of funcdef
- code has gotten pretty crazy
    - parser33 and ast are both around 300 lines
- "function test(a) { a = a * 10 \n return(a + 2) } \n test(2)" -> [None, 22]
- figuring out difference between FunctionDef/FunctionCall and their interaction was challenging
    - "wait, no that actually doesn't make any sense"
    - still lots of different bugs and things to figure out
- wrote "Compile" class (in heavy quotes lol) that makes printing and examining output easier

( 09:21:46 AM | Mon Nov 04 2019 )
- rewrote unittests for compile object
- more function definitions working
- starting to make silly mistakes and have to go to class soon..
- ast needs pretty big rewrite once fleshed out more

( 05:37:16 AM | Tue Nov 05 2019 )
- working for last 4 hours or so
- lost of housecleaning in ast and parser
- added boolean operands and equivalance/comparison (!=, ==, <, >, etc), in the process
  of testing them
- still only have numbers for datatypes
- got one or two more function defs working
- spent the last 30-45 min or more fixing negative operator
    - made it way simpler by adding another case to the regex so a Minus token wouldn't be
      parsed instead in cases like -9 * -10
    - got rid of   number  : NEGATIVE FLOAT   and   expr  : NEGATIVE LPAREN expr RPAREN
                           | NEGATIVE INTEGER             | NEGATIVE NEGATIVE expr
    - hadn't really looked at that area since adding statements
    - tried stmt : NEGATIVE expr  ->  Mul(expr, Integer(-1))
          - seemed pretty clever at the time but didn't work and inefficient
          - still wondering if compound negative statements will need to be added differently
    - instead just using the FlipSign object I almost threw out earlier while cleaning
    - it was able to replace all 4 of those rules and now stuff like "-9 * -10" works
    - also tried   expr | NEGATIVE NEGATIVE expr  which alone caused 18 reduce/reduce conflicts
                   expr | NEGATIVE expr

- ehh.. spoke too soon, half around later and running into some negative problems evaluating variables, FlipSign has some downstream effects

( 07:27:44 AM | Tue Nov 05 2019 )
- really annoying case ->  "let x = 1 \n -x * 2"
  - seems simple but but i've been stuck here for a while
  - finally fixed it by expanding the negative regex expression even more, which is starting to seem ridiculous
      - "^-|(?<=\()-|(?<=[\+\-\*\/\^])-|(?<==\s)-|(?<=[^0-9./)])-(?=[0-9.a-zA-Z])"
      - actually just made it slightly longer and fixed a case after pasting it in here
      - isn't this what the parser is for? can't we write in all the cases where a negative symbol should be added instead of minus?..
      - still doesn't fully work.. "let x = 1 \n --x * 2" ..


( 07:10:26 AM | Thu Nov 07 2019 )
- working for last 7+ hours
- nested function calls work, e.g "f(g(x))"
- expressions containing function calls work, e.g. "1 + f()"
    - e.g. "function f(a,b){ let c = (a+1)/(b - 1) \n return(c) } ; 
            function g(x){return(x+1)} ; f(g(1),7) + 2"
    - this took a lot of work, having "stmt -> func_call" was the biggest problem
      and I didn't think of just removing of it
    - now "expr : func_call" as we wanted for a while
    - don't know why I didn't see that.. definitions can contain new lines but calls don't
      so there's no good reason it can't be an expr, just assumed that rule was needed
- realized in fixing sr/rr conflicts that arg_list object shouldn't be the same 
  for func call/def, oops..
    - it worked but required unnecessary handling, func_def should only be passed identifiers
- cleaned up function section of ast
- fixed precedence rules, a bunch were unnecessary or wrong
    - order of operators for POW and NOT.. 
- added ** to regex for pow, new arithmetic unittests using add/sub/mul/div
  that didn't work initally
- simplified some production rules
    - a : b  (both nonterminal) is only really useful/meaningful if it's 
    restricting the use of b or creating an object
- negative still causing issues, new rule I added in last entry makes it match 1 -1 or x-1


( 02:34:35 PM | Sun Nov 10 2019 )
- working a lot of this morning and last night
- added if/elif/else
- tried too many different syntax variations and it became a bit of a mess
  - can definitely see the appeal to having just one way to do something
- mass renaming, FUNCTION IDENTIFIER LPAREN arg_list RIGHTPAREN  --->  DEF ID ( arg_list )
- the way if statements are defined is kind of messy, will probably change
- looking at a lof of c++ and javascript syntax for ideas

( 03:49:15 AM | Mon Nov 25 2019 )
- been a while
- quite busy lately and lacking motivation, felt like i was just adding the features a language
  "should" have and basically building a slower python
- finding Jelly and a few other random languages renewed some interest
- can't remember exactly what was added since last entry
- did a basic while loop but it's not very interesting
- today wrote a simple interactive shell which revealed A LOT of bugs and how strict and
  difficult to understand multiline parsing is right now
- added conditional expressions at some point (i.e. x = 10 ? 1 : -1)
- did we have implicit return lambdas before? (i.e. f(x)=>{x*10})

( 03:16:45 AM | Wed Nov 27 2019 )
- interpreter is much better and it helped fix a lot of parsing problems
- realized the other night that the way functions are defined basically makes them first class
  - really cool moment where i passed a function as an argument and it worked
  - returning functions also works!
  - added variables from parent scope at time of definition to function_call namespace
    - this makes closure and recursion possible
    - another really cool moment when i ran f(x)=>f(x) and the screen was instantly filled with
      scrolling output until it hit python max recursion limit
    - the way this is done now is pretty hacky and will have to change
- arrow definition parsing was pretty broken and it took hours at bcit the other night to
  realize that it's because there is no token before the arrow function id that would signify
  it's not any other type of id
- wrote a regex for ARROW_ID and that fixed it
- x = y = f(2) works, same with f = g = return_a_function()
- if statements still aren't very solid, not confident using them
- still 4 shift/reduce warnings that have been around forever related to ELSE
- hard to get out of recursion without if statements or multiple returns
- oh yeah, NEWLINE is no longer a thing.. it's completely ignore by the lexer
    - was way too buggy and difficult somehow

( 09:03:45 PM | Sat Dec 07 2019 )
- working for 5 hours or so
- added "spaceship" operator (triple comparison) and comparison assignments
    - e.g. let x = y <=> z ? -10 : 0 : 10
- added elif_list and switch statements
    - a lot easier than I thought it was.. was trying to copy the other "list" types without thinking
    - if/elif/else can use : or { } depending on whether the block is an expression
    - switch doesn't need a parent expression to compare cases to (can have case expressions)
        - e.g. switch { case y > 0: ... case y < 0: ... default: .. }
    - don't really understand why break is needed in c++/js/go, other than maybe cases
      that share code or switches inside of switches, added it anyways for blocks
    - try to add a block case without them
- fixed arrow function regex to allow spaces
    - didn't realize I couldn't do things like f( x, y ) => x+y
    - had to make the regex a lot longer but it's pretty robust now
- added comments to lexer ignore in the form /* possibly multiline comment */
- added run_file.py, really nice actually writing code out with formatting
    - only used unittests and interpreter up to this point
- no more shift/reduce warnings!
    - realized the two for ELSE that have stuck around forever were due to 1 production rule
    - 'stmt : IF expr : expr ELSE expr' fixed it (used to have stmt inside which was ambiguous recursion)
- parser33 and ast are both around 500 lines