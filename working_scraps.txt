from unittest.mock import patch
import io

@patch('sys.stdout', new_callable=io.StringIO)
mock_out.getvalue()

for t in lexer.lex(p1):
    print(t)

# lg.add('NO_EQUALS', r'^([a-zA-Z0-9_\+\-\*\/\^\s\(\).,]+)')



class ConditionalAssignment(Node):
    def __init__(self, identif, bool_stmt, assign_true, assign_false):
        self.identif = identif
        self.bool_stmt = bool_stmt
        self.assign_true = assign_true
        self.assign_false = assign_false

    def eval(self, space):
        result = self.bool_stmt.eval(space)
        if result:
            Assignment(self.identif, self.assign_true).eval(space)
        else:
            Assignment(self.identif, self.assign_false).eval(space)


"""#@pg.production('expr : MINUS NEG ID')
#@pg.production('expr : ID MINUS NEG')
@pg.production('expr : + + ID')
@pg.production('expr : ID + +')
def inc_dec_id(state, p):
    print( p[0].gettokentype() )
    if p[0].gettokentype() == 'PLUS' or p[1].gettokentype() == 'PLUS':
        Assignment(p[2], f'{p[0]} = {p[0]} PLUS 1')"""


# print(f"Return stmt of '{self.name}' : {func_def.return_stmt}")
# print(f"Return value of '{self.name}' in '{func_space}' : {return_value}")


complex_negatives = [
    ('double neg', '--2', 2), ('trip neg', '---2', -2), ('quad neg', '----2', 2),
    ('nested trip neg', '-(--(2))', -2), ('sub nested neg', '2--(-2)', 0),
    ('single neg var', 'let x = -1 ; -x*2', [-1, 2]),
    ('double neg var paren', 'let x = -1 ; (--x)*2', [-1, -2]),
    ('double neg var', 'let x = -1 ; --x*2', [-1, -2]),
    ('sub vs neg var, no space', 'let x = -1 ; --x-2', [-1, -3]),
]

    def test_complex_negatives(self):
        for m, p1, ans in complex_negatives:
            with self.subTest(msg=m, case=p1, expected=ans):
                program = Compile(p1)
                print('=' * 30 + '\n' + f'{p1} = {program.output}' + '\n' + '=' * 30)
                self.assertEqual(ans, program.output)